## RTOS任务编写（设计与组织）

RTOS的难点与强大就体现在任务的组织与设计之上，在学习RTOS的过程中，我对任务设计与组织进行了一个简单的总结，基本包含了RTOS的常用元素。

每个任务都是独立的，就像一具身体，灵魂则是CPU，当CPU调度哪一个任务，那么这个任务就获得灵魂，开始执行。

### 那么如何进行任务设计呢？

我觉得一共要考虑三个元素分别是**任务函数的结构**、**任务设计中的问题**、**任务函数的本身代码设计**。

#### 1、任务函数的结构：

任务函数的结构其实也就是任务函数的性质，我总结了一般有三类任务，分别是单次执行的任务，周期性执行的任务，事件触发执行的任务。

**单次执行的任务**：只执行一次，执行完成后自行删除。此类任务通常是孤立任务，不和其他任务进行通信，只使用共享资源来获取信息和输出信息。例如我的那个UCOS项目中，采样任务任务就是此类型，当用选中了开始采样时才创建执行。

**周期任务**：主动调用OSTimeDly()来调整自身的执行周期。安排得当时，任务执行周期的相对误差会比较小，如果希望很精准的周期，可以采用独立定时器触发任务。有一些特定任务，如键盘扫描，动态显示刷新任务等适合此类任务。

 **事件触发任务**：某一任务创建后在执行时需要等待某种事件发生，在此之前被操作系统挂起。例如我的UCOS项目中，串口发送任务与ISR串口中断配合，发送任务首先发送数据帧的前几位，然后打开串口中断，进入等待，剩余的数据则是在串口中断中完成，完成之后发送信号量，串口发送任务继续执行，删除自己。



#### 2、任务设计需要考虑的问题：

**任务的优先级：**松散、根据一些原则划分如中断关联性、紧迫性、关键性、频繁性、快捷性、传递性。

**公共函数调用问题：**互斥调用（关中断、关调度）、可重入设计（局部变量）

**与其他任务协调：** 行为同步

**共享资源的访问：** 资源同步

**与其他任务进行数据通信：** 常见通信方式



#### 3、最后就是任务函数本身的设计：

有一个原则，凡是操作系统提供了的服务功能，必须调用相应的服务函数，使用自己定义的服务函数是很冒险的。

任务之间不仅有数据流动，还有行为互动，而且互动之间的作用是通过操作系统的服务来实现的。

同时，任务函数本身的设计和编写者的代码功底有很大的相关性，这里我就不多做阐述了，需要的是厚积薄发。

不过有几个点在写任务函数代码的时候可以注意一下，分别是 **系统总体关联图**、**任务关联分析**、**任务的程序流程图**，归纳起来也就是先思考，再写代码。

 ### 任务组织

需要结合任务设计中的几个点，系统总体关联图，任务关联分析来组织任务，总的来说，有以下几个方面需要注意。

**设备依赖任务的划分：**以CPU为中心，将各种不输入/输出设备相关的功能划分为独立的任务。

**关键任务划分：**必须保证关键任务的执行，**不能被遗漏一次**，不能被其他任务拖累，可以放在中断或者独立为高优先级任务，通过“第三者”传输信息，触发其他任务。

**紧迫任务：**必须在规定时间内完成，可以遗漏一两次，可设计在中断中或者单独的高优先级任务。

**数据处理任务：**可单独划分出来，设置较低优先级

**功能聚合：**如果功能相似，可设计为一个任务，**减少异步通信，减少系统消耗**。

**触发条件相同任务：**由相同时间触发的若干功能组合为一个任务，**免除事件分发机制**。

**运行周期相同任务：**运行周期相同的功能组合到一个任务，免除时间事件分发机制。

**顺序执行功能：**顺序执行的功能组合为一个任务，免除同步接力通信的麻烦。



## UCOS内核原理

任务的创建--抢占式调度--任务切换

在学习UCOS的时候我把UCOSII和UCOSIII做了个简单的对比学习，因为UCOSII的资料多一点，所以对UCOSII有所侧重。

首先每个任务都有一个**TCB**，他就是任务的身份证，记录了任务的所有信息，比如，栈的位置，任务名称，任务形参。

UCOS提供了很多空的任务控制块，这些空闲控制块是一个控制块类型的数组，他们之间也是一个单项的链表互相连接。

当我我们创建任务的时候，从空闲控制块中分离出控制块来做当前创建任务的TCB。这些控制块再互相连接在一起形成**双循环链表**，同时UCOSII还有一个优先级数组，以优先级为顺序存放指向各个任务控制块的指针这样就可以 不用遍历链表，直接操作数组进行切换了，速度更快。任务有五个状态，那么比较重要的就是就绪状态了，就绪状态的任务随时准备被调度执行。在UCOSII中，任务的就绪表是一个数组，通过判断这个未是否被置一来表示任务是否就绪，每次进行任务切换的时候找到最高优先级任务进行切换，那么抢占式调度也是在这发生，我觉得这里写的非常巧妙，也是UCOS的一个精髓吧。

那么抢占式调度就是在这，调度发生的情况一般有三种，  

外部中断导致高优先级就绪、SysTick的定时中断、以及任务主动释放CPU发生切换。

每次发生任务调度，其实最后都是在PENDSV中断中完成切换的，调度时，查找最高优先级任务是否就位，如果就位就进行切换，这样就出现了抢占式调度。

那么在UCOSIII中，很多概念都是差不多的，不同的主要是在就任务链表，UCOSIII中对任务链表进行了升级，对于就绪任务来说有专门的数据结构进行管理。对于就绪任务，有一个就绪数组，它的元素时OS_RDY_LIST的数据类型。**这个数组的每一个元素都有一个指向TCB类型的头指针和尾指针**，也就是说每一个元素对应一个优先级，同时相同优先级任务形成双循环链表，这个数组的元素指向头节点和尾节点。那么这也是UCOSIII执行同级任务的时间片轮询的原因，在这样的数据结构管理之下，很容易做到。同时要实现任务切换调度，UCOSIII有很多数据结构的操作去实现和查找最高就绪的优先级任务，那么这里也是UCOSIII的一个精华以及一个难点，我也是正在学习当中。











