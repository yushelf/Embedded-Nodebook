# 概述

虚拟内存主要有三个目标，首先是透明，让每个进程看不见操作系统，误以为自己是独立的，其次是效率，最后是保护。同时虚拟化内存需要很多机制，这些机制需要操作系统和硬件的支持，同时也需要一些关键的策略。

## 内存

存储单元一般应具有存储数据和读写数据的功能，以8位二进制作为一个存储单元，也就是一个字节。每个单元有一个地址，是一个整数编码，可以表示为二进制整数。程序中的变量和主存储器的存储单元相对应。变量的名字对应着存储单元的地址，变量内容对应着单元所存储的数据。存储地址一般用十六进制数表示，意思就是每个存储单元都有自己唯一独立的数字作为表示，而每一个存储器地址中又存放着一组二进制（或十六进制）表示的数，通常称为该地址的内容，例如00001111、11010010等。
有了这个概念，这里就可以解释一下计算机的位数与所支持最大内存之间的关系，比如说32位的系统，32位系统的“32”位是指cpu的地址总线是32根，其最多能有2^32次方个地址，每个地址都有其独立唯一的编号，如下图：

![img](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210715215356.png)

4G = 2^32 乘以 8（bit）,每8（bit）是一个字节，也是一个存储单元，都有其唯一独立的地址，那么32位系统一共能表示232次方个地址，每个地址是8bit,232乘以8等于2^35次方（bit）,正好是4G的内存，那么64位系统最多支持多大内存呢？答案是2的32次方G，不过这么大是基本不可能的，当今计算机的寻址能力根本达不到，不过128G还是可以达到的。

# 机制

## 一、地址转换

### 1.概述

硬件配合操作系统完成地址转换。CPU需要两个寄存器，基址寄存器和界限寄存器。它们能够将地址空间放在物理内存的任何位置，同时又能确保进程值访问自己的地址空间。

> 物理地址 = 虚拟地址+基址寄存器地址

> 界限寄存器记录地址空间大小，在硬件将虚拟地址与基址寄存器内容求和前，检查这个边界，或者记录地址空间结束的物理地址，等到硬件转换完成后再检查边界。

有时我们将CPU的这个负责地址转换的部分统称为内存管理单元（MMU）

### 2.硬件在地址转换时需要提供的支持

+ 特权模式
+ 基址、界限寄存器
+ 能够转换虚拟地址并且检查它是否越界
+ 修改基址、界限寄存器的特权指令
+ 注册异常处理程序的特权指令
+ 能够触发异常

### 3.操作系统需要提供的支持

在硬件提供的支持上，合理的进行调用，在进程创建，结束，切换，异常时，都应该有相对应的操作。

### 4.小结

地址转换能制造进程独享内存的假像，并且能提供有效的保护，但是效率不够高，容易造成分配的内存不适用，内部碎片过多，所以我们需要更复杂的机制，避免内部碎片。将基址加界限的概念稍微泛化----”分段“。

## 二、分段

### 1.概述

**每个程序存储在磁盘上，被分成特定的段，加载至内存中，程序中的地址为偏移量，当运行时被重定位，也就是加上基地址。重定位过程：每个段都有一个基地址记录在程序的“PCB（控制块）”中。基地址根据查表得到，此表名为LDT，也叫寄存器（内存映射表，段表），每个进程都有自己的LDT，由硬件操作查询。每次进程进程切换，表中的基地址也会被更改。**（B站哈工大操作系统课程）

在地址转换的基础上，再增加硬件支持，将程序每个段分开存入物理内存，这样就能避免内部碎片，提高内存的适用。具体做法就是，加入寄存器，可以通过地址的前两位来当标志位，显式地说明要引用的段，任然保持基址和界限寄存器，针对不同的段寄存器则不同。

### 2.小结

分段任然存在缺陷，不能完全避免”外部碎片“----当一个进程需要20K的段，但是当前最大的段为20K;或者一个很大但是稀疏的堆都在一个逻辑段中。我们需要学习**“空闲空间管理”**（见此文件夹另一个文件）。

## 三、分页

### 1.概述

解决内存分区（程序分段存储）导致的内存效率问题。

**在操作系统初始化的时候，mem_mep()函数负责初始化，就把物理内存分成一页一页的，每一页都有一个记录，如每4K一页，也会被被标记是否使用，为0则是没有使用，当需要寻找那一页空闲时可以来此函数寻找；同时程序的每个段也被等分成页，换算成多少页，不足时取整。将页存入内存。**（B站哈工大操作系统课程）

分页不是将一个进程的地址空间分割成不同长度的逻辑段，而是分割成固定大小的单元，每个单元称为一页。相应的，把物理内存看成定长槽块的阵列，叫做页帧。

>分页比较灵活，操作系统能够高效地提供地址空间的抽象
>
>分页提供的空闲空间管理具有简单性

**页表：**为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表。

**虚拟页面号：**virtual page number,VPN

**页内偏移量：**offset

**物理页号：**physical page number,PPN

### 2.页表存在哪

可以存在物理内存，也可以存在虚拟内存，甚至可以存在磁盘上

### 3.页表有什么

最简单的页表就是线性页表，就是一个数组，通过虚拟页号检索数组，找到页表项（PTE），从页表项中找到物理帧号（PFN）。

页表项中内容:许多标志位，如有效位，保护位，存在位，参考位等等，标志位剩下的就是PFN。

**页表大小：**

**例如：VPN为20，则需要2^20^次方个转换，也就是数组元素要有2^20^个，同时还有许多标志位，所以假设每个元素为4字节，那么最后页表大小为2^20^*4字节。**

### 4.页表地址转换

由MMU硬件转换：

![image-20210720224311060](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210720224320.png)

此时每一页的大小为4K，那么逻辑地址需要除此地址，也就是向右偏移12位。（此处的运算是针对程序的分页计算需要重定位的地址）。

![image-20210720224516821](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210720224518.png)

得到程序中的页数之后，再去查页表，得到页框号，也就是内存的分页号数，然后再重定位。

![image-20210720224914857](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210720224916.png)

### 5.小结

此处的分页无法与分段较好的联系起来，我们需要引入新的机制或者策略，完美的实现虚拟内存。同时分页比较慢，需要许多额外的内存访问来访问页表，分页也会造成内存浪费，内存被页表塞满而不是有用的应用数据程序，为了解决这两个问题，**我们需要引入“快速地址转换”和“较小的表”**（见此目录另外两个文件，段页结合才是操作系统的内存管理）。

