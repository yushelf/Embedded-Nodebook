# 概述

虚拟内存主要有三个目标，首先是透明，让每个进程看不见操作系统，误以为自己是独立的，其次是效率，最后是保护。同时虚拟化内存需要很多机制，这些机制需要操作系统和硬件的支持，同时也需要一些关键的策略。

# 机制

## 一、地址转换

### 1.概述

硬件配合操作系统完成地址转换。CPU需要两个寄存器，基址寄存器和界限寄存器。它们能够将地址空间放在物理内存的任何位置，同时又能确保进程值访问自己的地址空间。

> 物理地址 = 虚拟地址+基址寄存器地址

> 界限寄存器记录地址空间大小，在硬件将虚拟地址与基址寄存器内容求和前，检查这个边界，或者记录地址空间结束的物理地址，等到硬件转换完成后再检查边界。

有时我们将CPU的这个负责地址转换的部分统称为内存管理单元（MMU）

### 2.硬件在地址转换时需要提供的支持

+ 特权模式
+ 基址、界限寄存器
+ 能够转换虚拟地址并且检查它是否越界
+ 修改基址、界限寄存器的特权指令
+ 注册异常处理程序的特权指令
+ 能够触发异常

### 3.操作系统需要提供的支持

在硬件提供的支持上，合理的进行调用，在进程创建，结束，切换，异常时，都应该有相对应的操作。

### 4.小结

地址转换能制造进程独享内存的假像，并且能提供有效的保护，但是效率不够高，容易造成分配的内存不适用，内部碎片过多，所以我们需要更复杂的机制，避免内部碎片。将基址加界限的概念稍微泛化----”分段“。

## 二、分段

### 1.概述

在地址转换的基础上，再增加硬件支持，将程序每个段分开存入物理内存，这样就能避免内部碎片，提高内存的适用。具体做法就是，加入寄存器，可以通过地址的前两位来当标志位，显式地说明要引用的段，任然保持基址和界限寄存器，针对不同的段寄存器则不同。

### 2.小结

分段任然存在缺陷，不能完全避免”外部碎片“----当一个进程需要20K的段，但是当前最大的段为20K;或者一个很大但是稀疏的堆都在一个逻辑段中。我们需要学习**“空闲空间管理”**（见此文件夹另一个文件）。

## 三、分页

### 1.概述

分页不是将一个进程的地址空间分割成不同长度的逻辑段，而是分割成固定大小的单元，每个单元称为一页。相应的，把物理内存看成定长槽块的阵列，叫做页帧。

>分页比较灵活，操作系统能够高效地提供地址空间的抽象
>
>分页提供的空闲空间管理具有简单性

**页表：**为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表。

**虚拟页面号：**virtual page number,VPN

**页内偏移量：**offset

**物理页号：**physical page number,PPN

### 2.页表存在哪

可以存在物理内存，也可以存在虚拟内存，甚至可以存在磁盘上

### 3.页表有什么

最简单的页表就是线性页表，就是一个数组，通过虚拟页号检索数组，找到页表项（PTE），从页表项中找到物理帧号（PFN）。

页表项中内容:许多标志位，如有效位，保护位，存在位，参考位等等，标志位剩下的就是PFN。

### 4.小结

分页比较慢，需要许多额外的内存访问来访问页表，分页也会造成内存浪费，内存被页表塞满而不是有用的应用数据程序，为了解决这两个问题，**我们需要引入“快速地址转换”和“较小的表”**（见此目录另外两个文件）。

