## 一、基本概念

因为在大型代码库中，组件之间有复杂的以来，同时软件开发者总是倾向于隐藏细节，封装代码，因此有些锁的调用顺序难以避免，从而导致互相争夺资源的局面造成死锁。

## 二、产生死锁的四个必要条件

+ 互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。
+ 持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。
+ 非抢占：线程获得的资源（例如锁），不能被抢占。
+ 循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。



## 三、破除死锁的办法

破坏四个必要条件即可。

+ 循环等待：正确调用锁的顺序
+ 持有并等待：持有并等待，也就是锁上加锁
+ 非抢占：在加锁之前检查一下这个锁是否有人用（但是会导致活锁）
+ 避免会产生死锁的程序同时运行（多个CPU错开执行）
+ 检查和恢复（放任），也就是定期重启

