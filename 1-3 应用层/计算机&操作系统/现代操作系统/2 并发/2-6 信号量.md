## 一、基本概念

与同步有关的所有工作的单一原语，可以代替锁和条件变量。同样的，利用底层的同步原语（锁和条件变量）就可以实现信号量。

信号量是有一个整数值的对象，可以用两个函数来操作它。

## 二、具体使用

首先一个信号量需要初始化

```c
#include <semaphore.h>
sem_t s;
sem_init(&s,0,1);//第二个参数一般设置为0，表示在同一进程的多个线程共享，第三个表示值初始化为1。
```

然后调用sem_wait()或者sem_post()与之交互。

**sem_wait**()：在信号量小于等于0是进入休眠队列等待，并且将信号量的值减一，直到有post就唤醒该等待队列的一个线程，当调用时，信号量的值大于等于1，也就是表示资源可用，那么就将信号量的值减一，并且直接执行调用线程的后面部分。

**sem_post**():对信号量加1，如果有等待的线程则唤醒一个等待的线程。

### 二值信号量（锁）

```c
sem_t m;
sem_init(&m,0,1);

sem_wati(&m);
//critical section here
sem_pose(&m);
```

用上面的方法，在需要加锁的代码中加入信号量的两个操作函数，并且将信号量初始化为1，就可以实现锁。

### 信号量用作条件变量

在这样的场景下，通常一个线程等待条件成立，另一个线程修改并发信号给等待线程，从而唤醒等待线程。

```c
sem_t m;

void *child()
{
 	sem_pose(&m);
}

int main()
{
	sem_init(&m,0,0);
    Pthread_create(c,NULL,child,NULL);
	//critical section here
	sem_wati(&m);
}
```







