## 任务的基本概念(UCOSII)

此处UCOSII和UCOSIII差别不大，本质是一样的。

### 任务控制块

+ 任务控制块TCB,相当于任务的身份证，里面存有任务的所有信息，包括，任务的栈的位置，任务名称，任务的形参等等。

1. + TCB是一个新的数据类型，定义在os.h中。

![image-20210527102828723](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210527102839.png)

#### 任务控制块链表

+ 系统会事先根据任务数量创建一批空的任务控制块。具体做法：在OSInit（）中建立一个OS_TCB结构类型的数组。

![image-20210527111622432](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210527111624.png)

+ 创建任务时系统就会将空任务控制块链表的头指针OSTCBFreeList指向的任务控制块分配出去，该任务块赋值之后，系统就按照任务控制块链表的头指针OSTCBList将其加入到**任务控制块链表**中。**（这里涉及到大量的链表操作，有空可阅读源码学习）**

+ 为了加快访问速度，除了将任务控制块链表设置为双链表，系统还设置了一个指针数组，OS_TCB* OSPrioTB1[],以优先级为顺序存放指向各个任务控制块的指针，这样就可以 不用遍历数组了。**（任务状态的变更，也会更新此处的优先级数组）**

![image-20210527112616558](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210527112618.png)

#### 任务控制块的初始化

在任务创建函数中会调用控制块初始化函数OSTCBInit().主要功能如下：

+ 取出一个空的任务控制块
+ 把任务的属性对任务控制块的各个成员赋值
+ 把这个任务控制块插入到任务控制链表中

### 任务堆栈

+ 任务都是相互独立的，不同于裸机程序，每个任务都有自己栈空间，通常栈空间又声明全局数组来创建。
+ 所有的任务控制块中都含有一个指向该任务堆栈的指针。
+ 需要根据处理器中堆栈增长的方向来确定栈顶的位置，再传递给OSTaskCreat()函数。

#### 任务堆栈初始化

当CPU运行一个任务时，CPU的各个寄存器需要预设一些值，堆栈就需要保存这些值以便能够在任务需要运行时将这些值放入CPU。堆栈初始化函数OSTaskStkInit()在OSTaskCreat()函数中调用，但是**OSTaskStkInit()需要根据不同的处理器来编写**。



## 就绪列表(UCOSII&UCOSIII)

**这个地方就是UCOSII和UCOSIII的不同，UCOSII是在任务创建的时候，就把所有的任务串在了一起，形成了双链表，同时还有一个OS_TCB* OSPrioTB1[],以优先级为顺序存放指向各个任务控制块的指针，而UCOSIII则是在此处进行了升级，根据任务的状态，分不同的情况形成双链表，如下图就绪数组会形成不同的双链表，那么等待任务又会有等待列表的数据结构。。。。**

在UCOSII中，任务就绪表是一个数组，通过每一位是否置一来判断任务是否就绪，找到最高位的任务后就把下标记住，通过，OS_TCB* OSPrioTB1[]即可找到最高优先级的任务，随后可进行任务切换。 

在UCOSIII中，系统对此处做了升级，加入了任务OS_RDY_LIST 数据类型的数组 OSRdyList[]  ，通过双链表管理等方法，也可以实现查找最高优先级任务（系统提供了一些函数进行相应的操作，用户不可调用此类函数），同时还能进行一个时间片的轮转调度。（此处待仔细研究）

![image-20210527151110620](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210527151111.png)

## 任务切换

任务切换分为上文保存和下文切换。

下文切换：

首先第一次进入pendsv异常会进行一个变量的判断，然后跳转到任务切换函数。

1. 将当前任务控制块OSTCBCurPtr指针的地址加载到R0
2. 加载任务就绪列表的指针地址到R1（最高就绪任务）
3. 执行LDR R2,[R1]      也就是将任务就绪列表的指针加载到R2
4. 将R2加载到R0，也就是把任务就绪列表指针存储到任务控制块中

然后进行手动加载，加载 OSTCBHighRdyPtr 到 R0

PSP指针会跟随寄存器向上移动，当下文切换完成时，PSP指针则指向下一个任务栈底 R0则始终存放着任务块指针

上文保存：

1. 获取进程SP，如果0，则跳过(goto     d)保存部分（第一次上下文切换）
2. 在进程堆栈上保存剩余的寄存器     r4-r11
3. 将进程SP保存在其TCB、OSTCBCurPtr->OSTCBStkPtr=SP；

![image-20210527154926228](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210527154927.png)

![image-20210527154946158](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210527154948.png)

## 任务调度(UCOSIII)

就是将就绪列表与任务调度，任务切换相连接起来。

1. 在OSInit中初始化优先级相关的全局变量。
2. 在任务控制块中加入任务优先级参数。
3. 在任务创建函数中添加相应的操作。
4. 修改     OS_IdleTaskInit()函数，是因为该函数调用了任务创建函数     OSTaskCreate()，OSTaskCreate()我们刚刚加入了优先级，所以这里我们要跟空闲任务分配一个优先级 。
5. 加入优先级之后，     OSStart()函数需要修改，具体哪一个任务最先运行，由优先级决定 。
6. 修改     PendSV_Handler()函数 。
7. 任务调用     OSTimeDly()函数之后，任务就处于阻塞态，需要将任务从就绪列表中移除 。
8. 任务调度函数     OSSched()不再是之前的两个任务轮流切换，需要根据优先级来调度 。
9. **OSTimeTick()函数在     SysTick 中断服务函数中被调用， 是一个周期函数，具体用于扫描就绪列表     OSRdyList[]，判断任务的延时时间是否到期，如果到期则将任务在优先级表中对应的位置位。**

