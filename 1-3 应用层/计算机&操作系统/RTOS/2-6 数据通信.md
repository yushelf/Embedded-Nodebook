## 全局变量

不能实现任务之间的相互关联，时效性较差。

当没有行为同步的要求时，传输数据不大，采用全局变量配合关中断的资源同步时一种经济有效的方法。（并且对共享内容的读写不是非常频繁，否则需要考虑大量的数据保护手段）



## 内存数据块

一般配合消息队列使用，动态内存管理的办法，管理消息内容数组。



## 消息邮箱

**具有行为同步功能的通信手段**，此类数据通信一般要求接收消息的任务总是在等待消息，一有消息就能在下一个消息产生之前处理完毕。如果双方的执行频度相同，也比较适合。同时操作系统对消息已经进行过互斥处理，双方在时序上互不打扰。

**消息不能是会消亡的局部变量！！！这样是很危险的**

+ 将消息保存在全局变量中。可行，只是消息被分离，可读性降低。
+ 将消息保存在ISR的静态局部变量中。可行，可读性良好。
+ **将消息内容冒充指针进行发送，只能发送不超过4字节的短消息，当消息为0时，会被操作系统当作空指针，需要稍加处理**。
  + 发送：正常发送数据时，消息指针的格式为（void *）&Temp，把Temp的地址传入，做为消息指针传递。冒充时：（void *）Temp。此时还可以进行简单的包装，如最高位置1。(void *)Temp|0xff000000.
  + 读取：正常读取时，*（INT32U *）Temp。冒充时：直接强制类型转换（INT32U）Temp，同时需要去除包装。



## 消息队列

接收方不能保证在下一条数据到来的时候处理完毕，则需要使用消息队列。

消息队列需要准备两个数组：**消息指针数组**，供实时操作系统用来排队使用；**消息内容数组**，用来保存消息，用户使用。

**发送消息时：**把消息存入消息内容数组，调用发送消息函数时则将这条消息的地址告诉实时操作系统，操作系统则会把这个地址按照入队算法加入到消息指针数组中。

**接收消息时：**操作系统按照出队算法从雄安锡指针数组中获得消息指针，用户再按照消息指针指针从消息内容数组中取出一条信息。

**实时操作系统的动态内存管理功能 可以用来管理消息内容数组。**（待仔细研究原理）

