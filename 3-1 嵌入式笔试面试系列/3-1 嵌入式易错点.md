## 数组

```c
#include <stdio.h>
int main()
{
      char ch[] = "helloworld";
      char *p = "helloworld";
      char a[]={'h','e','l','l','o','w','o','r','l','d','\0'};
      char b[]={"helloworld"};
      printf("ch:%s\np:%s\na:%s\nb:%s\n",ch,p,a,b);
      return 0;
 }
```

**在上述程序中，输出结果都是一样的，字符串是由双引号定义的，一般在结尾他会被自动加上\0，所以在初始化数组大小的时候，要把\0考虑进去**

**上述程序中，数组ch和b所占的空间相同，sizeof（ch）为11，sizeof(b)为11，可见，加了{}之后编译器并也会把\0考虑到字符串所占的位置中，但是b确实是一个字符串和a有本质的区别，这个通过printf以%s格式打印能看出了。**

**strlen函数会自动忽略\0**

## 字符

a的字符为97，A的字符为65！！

  char b[0]不分配空间，不占用内存空间。

## 指针

sizeof(指针)：实际上，指针在16位系统上的大小为2（如果你能找到一个），在32位系统上是4，在64位系统上是8

## 结构体字节对齐

sizeof 结构体（在结构体中定义变量，考察int,char分配字节数和字节对齐）


>字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则：
>
>1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
>2. 结构体每个成员相对于结构体首地址的偏移量都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；
>3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节

## 操作符

在C语言中，自增运算符++和指针运算符*的优先级关系为
左++ > * > 右++

## 关键字

### static

![image-20210626191112493](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210626191114.png)

### const

（1）  const int *p与int const *p等同

（2）  const int *p的含义是p是指向常量整形的指针

（3）  int *const p的含义是p是指向int的常量指针

（4）  常量指针：const在*前面，表示不能通过指针来改变变量的值

（5）  常指针：const在*后面，表示指针是一个常量，不能改变指针的指向，但是可以改变指针所指向变量的值

（6）  常指针不可以指向常量

（7）  常量指针可以指针常量和非常量

例子：

int a = 2；

const int b = 3；

const int *p；

p = &a；合法（p可以指向非常量）

p=&b；合法

p = 2；不合法（不能通过*p改变变量的值，因为p是指向常量变量的）

a = 3；合法

b = 4；不合法（b是一个常量变量）

 

int a = 2；

const int b = 3；

int * const p；

p = &a；合法

p = &b；不合法（因为b是常量，p是普通指针，可以通过*p改变变量的值，而b不允许被改变）

![img](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210626190714.jpg)

### volatile

![img](https://gitee.com/wang_chunfeng/pic-go/raw/master/img/20210626190643.jpg)