## 算法题常用输入输出

### scanf()

+ scanf也是要等回车,准确说是'/r'才会去读缓冲区的。
+ 用scanf输入字符串，整型以及浮点型数据时会把中间的分隔符（空格）丢弃，但是在结尾的最后一个‘\n’不会被丢弃，而当输入的是字符类型数据时，会把空格以及换行放在缓冲区中，这时就需要一个getchar来将空格或换行符从缓冲区中清除。
+ **scanf输入字符串时逗号不能作为分隔符**，用正则表达式,用%[^,]替代%s,意思是使scanf读取到逗号时停止读取.并且保留逗号, 
+ scanf处理单个字符时，不会把回车空格赋给字符串但是会赋给字符,就如同getchar一样,这时就要考虑'/n'的存在了。

```c
 while(scanf("%[^,\n]",&ch[i]) != EOF)
```



#### 小结

  如果scanf输入的不是字符,那么分隔符为回车,空格,tab键时,两个数据之间的分隔符只是起区别两个数据的作用,把分隔好的两个数据分别赋值到各自定义好的变量或数组中去,**两个数据之间的分隔符被从缓冲区读出但是不起任何作用,当然最后一个'/n'会被留在缓冲区内**,除非用getchar();或scanf("%c",&c);把它读出来.
回车是一定要有的,不管getchar还是scanf只要是通过缓冲区输入数据的函数都是等待回车键'/r'出现才进入缓冲区的。

### getchar()

+ 键盘输入的字符都存到缓冲区内,一旦键入回车,getchar就进入缓冲区读取字符,一次只返回第一个字符作为getchar函数的值,如果有循环或足够多的getchar语句,就会依次读出缓冲区内的所有字符直到'/n'.要理解这一点,之所以你输入的一系列字符被依次读出来,是因为循环的作用使得反复利用getchar在缓冲区里读取字符,而不是getchar可以读取多个字符,事实上getchar每次只能读取一个字符.如果需要取消'/n'的影响,可以用getchar();来清除,这里getchar();只是取得了'/n'但是并没有赋给任何字符变量,所以不会有影响,相当于清除了这个字符.还要注意的是这里你在键盘上输入ssss看到的回显正是来自于getchar的作用,如果用getch就看不到你输入了什么.
+ getch()和getche()是conio.h中的库函数，它的作用是从键盘接收字符。

### gets()







## 错误报告

操作系统调用函数执行任务时，存在失败的可能。标准库函数在一个外部整形白能量errno中保存错误代码之后把这个信息传递个用户程序，提示操作失败的标准原因。

perror函数简化向用户报告这些错误的过程。(定义在stdio.h)

``` c
void perror (char const *message)
```

如果message不是NULL，并且指向一个非空的字符串，perror则答应这个字符串，后面跟一个分号和一个空格，然后答应一条用于解释errno当前错误代码的信息。

## 终止执行

exit终止程序执行，定义在stdlib.h

```c
void exit(int status);
```

## 标准I/O函数库

具有一组I/O函数，在原来的基础上进行了许多拓展，同时引进了缓冲I/O的概念，提高了绝大多数程序的效率。

有一定的缺点，不同机器的实现效果可能不同，移植性略差。

## ANSI I/O概念

### 流

就C程序而言，所有的I/O操作只是简单的从程序移进或移出字节，这种字节流便被成为流。

缓冲区：一块内存区域，暂时保存数据。

文本流：文本行的长度，标准规定至少允许254个字符，同时不同的系统中某些特性不同，比如判断文本结束的方式，有的是换行加回车 （MS-DOS），有的则只是换行（UNIX）。

二进制流: 字节完全更具程序编写他们的形式写入到文件或设备中。

### 文件

**stdio.h所包含的声明之一就是FILE结构。它是一个数据结构，用于访问一个流。**

输入输出可更具系统文档油管I/O的说明进行重定向。

### 标准I/O常量

EOF：提示到达了文件尾

FILENAME_MAX：一个整形值，提示一个字符数组应该多大，以便容纳编译器所支持的最长合法文件名。

## 流I/O总览

