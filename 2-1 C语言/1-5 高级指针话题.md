## 高级声明

​	弄清楚指针的声明，就能知道指针具体是什么。像分析表达式一样分析指针的声明，会来的更加清楚与直接。**注意声明中各种符号的优先级，"[]"的优先级高于“星号“，函数“（）”的优先级高于“星号”**

## 函数指针

**函数指针初始化表达式中的&操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。&操作符知识显式地说明了编译器将隐式执行的任务**

### 回调函数

用户把一个函数指针作为参数传递给其他函数，后者将”回调“用户的函数。

`示例`

```c
/*
**在单链表中查找一个特定值的函数
*/
#include <stdio.h>
#include "node.h"

Node *serch_list( Node *node,void const *value,
                  int (*compare)(void const *,void const *))
{
    while(node != NULL)
    {
        if(compare(&node->value,value) == 0)
            break;
        node = node->link;
    }
    return node;
}

/*
**用于比较整数链表的函数
*/
int compare_ints(void const *a,void const *b)
{
    if(*(int *)a == *(int *)b)
        reurn 0;
    else 
        return 1;
}
```

### 转移表

**转换表就是函数指针数组**

使用得当可以用一句话替换很长的switch case语句。

```c
double add(  double, double );
double sub(  double, double );
double mul(  double, double );
double div(  double, double );
...

double (*oper_func[])( double, double ) = {
    add,sub,mul,div,...
}

result = oper_func[ oper ]( op1, op2 )
```

防止下标越界，否则很难排查。



## 命令行参数

